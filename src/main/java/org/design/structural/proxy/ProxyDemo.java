package org.design.structural.proxy;

/*
需求：
1、记录某个接口执行时间？
    修改源码，执行前后打印时间戳，时间戳相减就是执行时间。

2、如果无法修改源码怎么办？
（1）新建接口，继承原来的接口，执行前后加时间戳。(慎用继承，耦合度太高)
（2）聚合、代理：（有点像装饰模式）
    代理类与被代理类实现同一个接口；
    把被代理类传入代理类中，当作成员变量；
    在调用被代理方法前后增加操作。

3、代理有多种类型，比如LogProxy、AuthProxy，如何实现代理的各种组合？
（1）继承
（2）decorator

4、静态代理：
    在代理类中，被代理的对象类型改成被代理对象实现的接口类型；
    越来越像装饰者模式；
    设计模式即多态的简单运用；

5、如何实现代理多个方法？毕竟日志记录、时间计算是很多方法都需要的功能。
如何实现代理多个类？想让LogProxy、AuthProxy可以重用，不仅可以代理A，也可以代理其它可以代理的类型Object。
怎么实现代理的任意组合？
解决办法：
    分离代理行为与被代理对象
    jdk动态代理

6、如果不知道被代理类的接口呢？ 想代理任意对象怎么办？
使用jdk动态代理，利用反射实现，在运行过程中分析字节码文件，找出方法，并调用。

7、横切代码与业务逻辑代码分离AOP

8、通过反射观察生成的代理对象。jdk反射生成代理必须面向接口，这是由Proxy的内部实现决定的。

asm 直接操纵二进制码，用了asm，Java才真正是动态语言。
反射只能读出来用，但是无法修改。
cafe babe代表Java的class
class文件，不需要源码就可以生成，任何语言都可以编译成class文件。
Java、Scala、kotlin编译完之后都在JVM中执行

Jdk动态代理的局限：
    jdk反射生成代理必须面向接口，这是proxy的内部实现决定的。
    被代理类必须有实现的接口

其它实现动态代理的方式：
（1）instrument 调琴弦
    Java自带的，钩子函数，拦截器，class load 到内存中拦住class，实施自己的定制，直接修改二进制码，完全控制二进制码。
    比asm强大，我们使用asm是通过asm的api，而instrument可以直接修改二进制码，比较繁琐，必须知道每个01代码什么含义。
（2）cglib（比jdk简单，不需要实现接口）

 */
public class ProxyDemo {
    public static void main(String[] args) {

    }
}
